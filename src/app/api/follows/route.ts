import { NextResponse } from 'next/server'
import { supabaseAdmin } from '@/lib/supabase'
import { addFollow, removeFollow, getFollowersCount, hasFollow } from '@/lib/localFollowStore'

// Helper: detect missing relation error for graceful setup message
function isMissingRelation(error?: { message?: string }) {
  if (!error?.message) return false
  const msg = error.message.toLowerCase()
  return msg.includes('relation') && msg.includes('does not exist') || 
         msg.includes('could not find') && (msg.includes('column') && (msg.includes('user_address') || msg.includes('user_wallet') || msg.includes('user_id')))
}

// Helper: detect FK constraint errors
function isUserIdForeignKeyViolation(error?: { message?: string }) {
  if (!error?.message) return false
  const msg = error.message.toLowerCase()
  return msg.includes('violates foreign key constraint') && msg.includes('event_follows_user_id_fkey')
}

// Helper: detect integer type mismatch on user_id column
function isUserIdTypeIntegerError(error?: { message?: string }) {
  if (!error?.message) return false
  const msg = error.message.toLowerCase()
  return msg.includes('out of range for type integer') || msg.includes('invalid input syntax for type integer')
}

const enableFallback = process.env.ENABLE_LOCAL_FOLLOW_FALLBACK === 'true'

// Robust body parser to handle various client payloads (single-read)
async function parseRequestBody(req: Request) {
  const contentType = req.headers.get('content-type') || ''
  try {
    if (contentType.includes('application/json')) {
      const text = await req.text()
      try { return JSON.parse(text) } catch { return {} }
    }
    if (contentType.includes('application/x-www-form-urlencoded')) {
      const text = await req.text()
      const params = new URLSearchParams(text)
      return Object.fromEntries(params.entries())
    }
    if (contentType.includes('multipart/form-data')) {
      const form = await (req as any).formData?.()
      if (form && typeof (form as any).entries === 'function') {
        const obj: Record<string, any> = {}
        for (const [k, v] of (form as any).entries()) {
          obj[k] = v as any
        }
        return obj
      }
      return {}
    }
    // Fallback: try text->JSON
    const text = await req.text()
    if (text) {
      try { return JSON.parse(text) } catch { return {} }
    }
    return {}
  } catch (_) {
    return {}
  }
}

// POST /api/follows  body: { predictionId: number, walletAddress: string }
export async function POST(req: Request) {
  try {
    const body = await parseRequestBody(req)
    const predictionId = Number(body?.predictionId)
    const walletAddress = String(body?.walletAddress || '')

    if (!predictionId || !walletAddress) {
      return NextResponse.json({ message: 'predictionId 与 walletAddress 必填' }, { status: 400 })
    }

    // 首先尝试插入（若缺表或结构错误按策略处理）
    const { data, error } = await supabaseAdmin
      .from('event_follows')
      .insert({ user_id: walletAddress, event_id: predictionId })
      .select()
      .maybeSingle()

    if (error) {
      if (isMissingRelation(error) || isUserIdForeignKeyViolation(error) || isUserIdTypeIntegerError(error)) {
        if (enableFallback) {
          const localFollow = await addFollow(walletAddress, predictionId)
          return NextResponse.json({
            message: '已关注(使用本地后备存储)',
            follow: localFollow,
            fallbackUsed: true,
            setupRequired: true,
            sql: `
ALTER TABLE public.event_follows ALTER COLUMN user_id TYPE TEXT;
CREATE UNIQUE INDEX IF NOT EXISTS event_follows_user_id_event_id_key ON public.event_follows (user_id, event_id);`
          }, { status: 200 })
        } else {
          if (isMissingRelation(error)) {
            return NextResponse.json({
              message: '缺少 event_follows 表，请手动在Supabase控制台执行以下SQL',
              setupRequired: true,
              sql: `
DROP TABLE IF EXISTS public.event_follows CASCADE;

CREATE TABLE public.event_follows (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id TEXT NOT NULL,
  event_id BIGINT NOT NULL REFERENCES public.predictions(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (user_id, event_id)
);

ALTER TABLE public.event_follows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all operations on event_follows" ON public.event_follows
FOR ALL USING (true) WITH CHECK (true);`
            }, { status: 501 })
          }
          if (isUserIdForeignKeyViolation(error)) {
            return NextResponse.json({
              message: 'event_follows.user_id 外键约束导致插入失败',
              setupRequired: true,
              detail: error.message,
              sql: `
ALTER TABLE public.event_follows DROP CONSTRAINT IF EXISTS event_follows_user_id_fkey;
ALTER TABLE public.event_follows ALTER COLUMN user_id TYPE TEXT;
CREATE UNIQUE INDEX IF NOT EXISTS event_follows_user_id_event_id_key ON public.event_follows (user_id, event_id);`
            }, { status: 501 })
          }
          if (isUserIdTypeIntegerError(error)) {
            return NextResponse.json({
              message: 'event_follows.user_id 列类型为整数，需改为 TEXT',
              setupRequired: true,
              detail: error.message,
              sql: `
ALTER TABLE public.event_follows ALTER COLUMN user_id TYPE TEXT;
CREATE UNIQUE INDEX IF NOT EXISTS event_follows_user_id_event_id_key ON public.event_follows (user_id, event_id);`
            }, { status: 501 })
          }
        }
      }
      return NextResponse.json({ message: '关注失败', detail: error.message }, { status: 500 })
    }

    return NextResponse.json({ message: '已关注', follow: data }, { status: 200 })
  } catch (e: any) {
    return NextResponse.json({ message: '请求处理失败', detail: String(e?.message || e) }, { status: 500 })
  }
}

// DELETE /api/follows  body: { predictionId: number, walletAddress: string }
export async function DELETE(req: Request) {
  try {
    const body = await parseRequestBody(req)
    const predictionId = Number(body?.predictionId)
    const walletAddress = String(body?.walletAddress || '')

    if (!predictionId || !walletAddress) {
      return NextResponse.json({ message: 'predictionId 与 walletAddress 必填' }, { status: 400 })
    }

    const { error } = await supabaseAdmin
      .from('event_follows')
      .delete()
      .eq('user_id', walletAddress)
      .eq('event_id', predictionId)

    if (error) {
      if (isMissingRelation(error) || isUserIdForeignKeyViolation(error) || isUserIdTypeIntegerError(error)) {
        if (enableFallback) {
          const removed = await removeFollow(walletAddress, predictionId)
          return NextResponse.json({ message: '已取消关注(使用本地后备存储)', removed, fallbackUsed: true }, { status: 200 })
        } else {
          if (isMissingRelation(error)) {
            return NextResponse.json({
              message: '缺少 event_follows 表，请先创建再重试',
              setupRequired: true,
              sql: `
CREATE TABLE IF NOT EXISTS public.event_follows (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id TEXT NOT NULL,
  event_id BIGINT NOT NULL REFERENCES public.predictions(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (user_id, event_id)
);`
            }, { status: 501 })
          }
          if (isUserIdForeignKeyViolation(error)) {
            return NextResponse.json({
              message: 'event_follows.user_id 外键约束导致删除失败',
              setupRequired: true,
              detail: error.message,
              sql: `
ALTER TABLE public.event_follows DROP CONSTRAINT IF EXISTS event_follows_user_id_fkey;`
            }, { status: 501 })
          }
          if (isUserIdTypeIntegerError(error)) {
            return NextResponse.json({
              message: 'event_follows.user_id 列类型为整数，需改为 TEXT',
              setupRequired: true,
              detail: error.message,
              sql: `
ALTER TABLE public.event_follows ALTER COLUMN user_id TYPE TEXT;`
            }, { status: 501 })
          }
        }
      }
      return NextResponse.json({ message: '取消关注失败', detail: error.message }, { status: 500 })
    }

    return NextResponse.json({ message: '已取消关注' }, { status: 200 })
  } catch (e: any) {
    return NextResponse.json({ message: '请求处理失败', detail: String(e?.message || e) }, { status: 500 })
  }
}

// GET /api/follows?predictionId=xx&walletAddress=xx
export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url)
    const predictionId = Number(searchParams.get('predictionId'))
    const walletAddress = String(searchParams.get('walletAddress') || '')

    if (!predictionId) {
      return NextResponse.json({ message: 'predictionId 必填' }, { status: 400 })
    }

    const { count, error: countError } = await supabaseAdmin
      .from('event_follows')
      .select('*', { count: 'exact', head: true })
      .eq('event_id', predictionId)

    if (countError) {
      if (isMissingRelation(countError) || isUserIdForeignKeyViolation(countError) || isUserIdTypeIntegerError(countError)) {
        if (enableFallback) {
          const localCount = await getFollowersCount(predictionId)
          let following = false
          if (walletAddress) {
            following = await hasFollow(walletAddress, predictionId)
          }
          return NextResponse.json({ 
            following, 
            followersCount: localCount, 
            fallbackUsed: true,
            setupRequired: true,
            sql: `
ALTER TABLE public.event_follows ALTER COLUMN user_id TYPE TEXT;
CREATE UNIQUE INDEX IF NOT EXISTS event_follows_user_id_event_id_key ON public.event_follows (user_id, event_id);`
          }, { status: 200 })
        } else {
          return NextResponse.json({
            message: '计数查询失败，需要修复表结构',
            setupRequired: true,
            detail: countError.message,
            sql: `
ALTER TABLE public.event_follows ALTER COLUMN user_id TYPE TEXT;
CREATE UNIQUE INDEX IF NOT EXISTS event_follows_user_id_event_id_key ON public.event_follows (user_id, event_id);`
          }, { status: 500 })
        }
      }
      return NextResponse.json({ message: '查询失败', detail: countError.message }, { status: 500 })
    }

    // 检查当前用户是否已关注
    let following = false
    if (walletAddress) {
      const { data: followData, error: followError } = await supabaseAdmin
        .from('event_follows')
        .select('*')
        .eq('user_id', walletAddress)
        .eq('event_id', predictionId)
        .maybeSingle()

      if (followError) {
        if (isMissingRelation(followError) || isUserIdForeignKeyViolation(followError) || isUserIdTypeIntegerError(followError)) {
          if (enableFallback) {
            following = await hasFollow(walletAddress, predictionId)
          } else {
            return NextResponse.json({
              message: '查询失败，需要修复表结构',
              setupRequired: true,
              detail: followError.message,
              sql: `
ALTER TABLE public.event_follows ALTER COLUMN user_id TYPE TEXT;`
            }, { status: 500 })
          }
        } else {
          return NextResponse.json({ message: '查询失败', detail: followError.message }, { status: 500 })
        }
      } else {
        following = !!followData
      }
    }

    return NextResponse.json({ following, followersCount: count || 0 }, { status: 200 })
  } catch (e: any) {
    return NextResponse.json({ message: '请求处理失败', detail: String(e?.message || e) }, { status: 500 })
  }
}